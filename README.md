# Apifi

- [Introduction](#introduction)
* [Installation](#installation)
* [Hello World](#hello-world)
    + [Domain model](#domain-model)
    + [Service layer](#service-layer)
* [Auto generated CRUD endpoints](#auto-generated-crud-endpoints)
* [CRUD API endpoint customization](#crud-api-endpoint-customization)
* [Additional auto generated endpoints](#additional-auto-generated-endpoints)
* [Free text search](#free-text-search)
  - [Overview](#overview)
  - [Domain model](#domain-model-1)
  - [Generated Service Layer](#generated-service-layer)
* [ApiHooks\<T>](#apihookst)
* [Embedded / foreign key Collections](#embedded---foreign-key-collections)
* [Spring security integration](#spring-security-integration)
    + [Overview](#overview-1)
* [License](#license)

## Introduction
Apifi is an API auto-generation tool which requires nothing more than a properly annotated Data Model in order to produce a ready-to-go GraphQL API. This library builds on top of [Datafi](https://github.com/sanda-dev/datafi) - a wrapper around spring-data-jpa which abstracts away the need to write any data access layer code manually. It has it's own Readme file but there should be little to no need to get into its details in order to make full use of this one.
### Installation

From its maven central [repository]():
```
<dependency>
  <groupId>dev.sanda</groupId>
    <artifactId>apifi</artifactId>
  <version>0.0.3</version>
</dependency>   
```

### Hello World
Apifi autogenerates GraphQL Service beans, containing all requisite queries and mutations for data model entities annotated as `@Entity` and / or `@Table`.
#### Domain model
```
@Entity
@WithCRUDResolvers({GET_BY_ID, CREATE, UPDATE})
public class Person{
    @Id @GeneratedValue
    private Long id;
    private String name;
    private Integer age;
    // getters & setters, etc...
}
```
#### Service layer
After compiling the project and taking a peek in the "target" folder, the following is the autogenerated GraphQL service:
```
@Service
@Transactional
@GraphQLApi
public class PersonGraphQLService {

  /* ... various injected dependencies ... */ 

  @GraphQLQuery
  public Person getPersonById(Long input) {
    return apiLogic.getById(input);
  }

  @GraphQLMutation
  public Person createPerson(Person input) {
    return apiLogic.create(input);
  }

  @GraphQLMutation
  public Person updatePerson(Person input) {
    return apiLogic.update(input);
  }
}
```
The Service bean is named by appending the String "GraphQLService" to the pascal case name of the given entity - hence "PersonGraphQLService". 
As you can see, there are three annotations on the class: 
- `@Service`: Tells Spring to include it in the application context. 
- `@Transactional`: Tells Jpa that database operations happen within retractable transactions.
- `@GraphQLApi`: Tells the [SPQR](https://github.com/leangen/graphql-spqr) Java-GraphQL framework (upon which this project heavily relies), to expose the contained queries and resolvers at the `/graphql` endpoint.

    _**Note:**_ _As mentioned, the default endpoint is `/graphql`, however this can be customized by setting the `graphql.spqr.http.endpoint=YOUR_CUSTOM_ENDPOINT_HERE` property in the `application.properties` / `application.yml` / other configuration source._

### Auto generated CRUD endpoints
Note the  `@WithCRUDEndpoints({GET_BY_ID, CREATE, UPDATE})` annotation on the Person entity, and their direct correspondence to the three auto-generated methods in `PersonGraphQLService`. There are 14 CRUDEndpoints options / types in total:

1. GET_PAGINATED_BATCH: Returns a sorted batch of the entity between a given offset and limit, sorted by a a field named in the `sortBy` argument, in either ascending or descending order, as is specified by the `sortingOrder` argument. The `offset` and `sortBy` arguments are mandatory, whereas the `limit` will default to 50, and the `sortingOrder` will default to ascending. 
2. GET_BY_ID: Fetch an instance of the entity by id.
3. GET_BATCH_BY_IDS: Fetch a batch of entity instances by their ids.
4. CREATE: Create a single entity.
5. BATCH_CREATE: Create a batch of entites.
6. UPDATE: Update a single entity. The id must of course be present in the inputted entity instance. This method doesn't update collections.
7. BATCH_UPDATE: Like the previous, pluralized.
8. DELETE: Delete a single entity instance.
9. BATCH_DELETE: Like the previous, in plural.
10. ARCHIVE: Archive a single entity instance. This and any related options are only valid if the entity in question implements the [`Archivable`](https://github.com/sanda-dev/datafi/blob/master/src/main/java/dev/sanda/datafi/persistence/Archivable.java) interface.
11. BATCH_ARCHIVE: Like the previous, pluralized.
12. DE_ARCHIVE: De-archive an entity instance.
13. BATCH_DE_ARCHIVE: Like the previous, pluralized. 
14. GET_ARCHIVED_PAGINATED_BATCH: Similar to GET_PAGINATED_BATCH, but specifically for entity instances which have been archived.
    
### CRUD API endpoint customization
Oftentimes there is a need for additional business logic on CRUD endpoints. This is where the [`ApiHooks<T>`](https://github.com/sanda-dev/apifi/blob/master/src/main/java/dev/sanda/apifi/service/ApiHooks.java) interface comes into play. It contains methods which are "hooked" or called at the appropriate times during the API endpoint request handling life cycle. For example; the `preCreate(...)` method is called prior to a new entity instance passed to the CREATE endpoint being saved to the database, and the `postCreate(...)` method is called immediately after the instance has been saved.  The same goes for any and all other phases of all the other options. As a rule, the hooked methods get passed the state which is relevant to the life cycle phase in which they are called, as well as a [`DataManager<T>`]([https://github.com/sanda-dev/datafi/blob/master/src/main/java/dev/sanda/datafi/service/DataManager.java](https://github.com/sanda-dev/datafi/blob/master/src/main/java/dev/sanda/datafi/service/DataManager.java)) bean instance for the entity.

To gain a better understanding as to how this works, see the following code snippet from the`ApiLogic<T>` class where the CRUD operational logic is generically implemented.  More specifically, this is the `batchCreate(List<T> input)` method: 

```
public List<T> batchCreate(List<T> input) {  
	if(apiHooks != null) // <--- note this
		apiHooks.preBatchCreate(input, dataManager);  
	val result = dataManager.saveAll(input);  
	if(apiHooks != null) // <--- and this
		apiHooks.postBatchCreate(result, dataManager);  
	logInfo("batchCreate: created {} new {} with ids [{}]", result.size(),toPlural(dataManager.getClazzSimpleName()), getIdList(result, reflectionCache).stream().map(Object::toString).collect(Collectors.joining(", ")));  
	return result;  
}
```
This pattern repeats itself in the same manner in all of the other `ApiLogic<T>` methods, allowing for the execution of custom defined logic prior to or following mutations and queries. In order to make use of this feature for an entity of type `T`:
1. create a public class which implements `ApiHooks<T>`
2. Make sure the class is wired into the application context (`@Component`, etc.).
3. Override whichever hooks are relevant. See the relevant source code [here](https://github.com/sanda-dev/apifi/blob/master/src/main/java/dev/sanda/apifi/service/ApiHooks.java).
No further configuration is necessary - Apifi leverages spring dependency injection to determine whether such a class has been created for a given entity. If such a service bean has indeed been created - it will be picked up and used by `ApiLogic<T>`. 

For example:
```
@Entity

public class Person{
    @Id
    private String id = UUID.randomUUID().toString();
    private String name;
    private Integer age;
    // getters & setters, etc...
}
```
Imagine there is a requirement to print a welcome message to the console after every time a new person is added, and a goodbye message after every time a person is deleted. To do so, a custom implementation of `ApiHooks<T>` can be implemented as follows:
```
@Component
public class PersonApiHooks implements ApiHooks<Person> {

    @Override
    public void postCreate(Person added, DataManager<Person> dataManager) {
        System.out.println("Hello " + added.getName() + "!");
    }

    @Override
    public void postDelete(Person deleted, DataManager<Person> dataManager) {
        System.out.println("Goodbye " + deleted.getName() + ":(");
    }
    
}
```
The same workflow applies to more complex use cases such as third party API calls, data related metrics, etc.

### Additional auto generated endpoints

In addition to the standard CRUD operation endpoints, custom endpoints can be added by making use of the following annotations:
-  `@ApiFindBy`: To fetch a list of entity instances with the search criteria being the value of a specific field, the field can be annotated with the `@ApiFindBy` annotation and a custom `List<...> get...By...(field value as arg)` resolver will be added to the GraphQL service bean. For example: 
    ```
    @Entity
    public class Person {
        @Id
        private String id = UUID.randomUUID().toString();
        private String name;
        @ApiFindBy
        private Integer age;
        private String address;
    }
    ```
    The above `@ApiFindBy` would generate the following resolver:
    ```
    @...
    PersonGraphQLService{
    ...
      //fetch a list of people who are "age" years old
      @GraphQLQuery
      public List<Person> findPersonsByAge(Integer age) {
        return apiLogic.apiFindBy("age", age);
      }
    ...
    }
    ```
-  `@ApiFindAllBy`: To fetch a list of entity instances with the search criteria being the value of a specific field being contained within a list of corresponding inputted values, the field can be annotated with the `@ApiFindAllBy` annotation and a custom `List<...> findAll...By...(list of field values to look for)` endpoint will be added to the GraphQL service bean. For example:
    ```
    @Entity
    
    public class Person {
        @Id
        private String id = UUID.randomUUID().toString();
        @ApiFindAllBy
        private String name;
        private Integer age;
        private String address;
    }
    ```
    The above `@ApiFindAllBy` would generate the following endpoint:
    ```
    @...
    PersonGraphQLService{
    ...
      //fetch a list of people whos name is included in the "names" list
      @GraphQLQuery
      public List<Person> findAllPersonsByNames(List<String> names) {
        return apiLogic.apiFindAllBy("name", names);
      }
    ...
    }
    ```
-  `@ApiFindByUnique`: To fetch a _single_ entity instance by the value of a unique field, the field can be annotated with the `@ApiFindByUnique` annotation and a custom `find...ByUnique...(field value)` endpoint will be added to the entities GraphQL service bean. For example:
    ```
    @Entity
    public class Person {
        @Id
        private String id = UUID.randomUUID().toString();
        private String name;
        private Integer age;
        private String address;
        @Column(unique = true) @ApiFindByUnique
        private String socialSecurityNumber;
    }
    ```
    The above `@ApiFindByUnique` would generate the following resolver:
    ```
    @...
    PersonGraphQLService{
      ...
      @GraphQLQuery
      public Person findPersonByUniqueSocialSecurityNumber(String socialSecurityNumber) {
       return apiLogic.apiFindByUnique("socialSecurityNumber", socialSecurityNumber);
      }
    ...
    }
    ```

### Free text search

##### Overview

Apifi comes with non case sensitive free text - or "fuzzy" search out of the box. This extends and relies upon the [free text search feature in Datafi](https://github.com/sanda-dev/datafi#free-text-search). To make use of this feature, annotate any **String typed** field with `@FreeTextSearchBy`, or alternatively, annotate the class itself with `@FreeTextSearchByFields({"field1", "field2", etc...})`. 

For example:

##### Domain model  
```  
@Entity
//@FreeTextSearchByFields({"name", "email"}) - this is equivalent to the field level annotations below
public class Person{  

@Id 
private String id = UUID.randomUUID().toString(); 
@FreeTextSearchBy
private String name;
@FreeTextSearchBy
private String email;
//...
}  
```  

##### Generated Service Layer  
```  
@...  
public class PersonGraphQLService{  
...
@GraphQLQuery
public List<User> personsFreeTextSearch(
String searchTerm, //in this case can be either (partial or complete) name  or email
int offset,
@GraphQLArgument(name = "limit", defaultValue = "50") int limit,
@GraphQLArgument(name = "sortBy", defaultValue = "id") String sortBy,
@GraphQLArgument(name = "sortDirection", defaultValue = "\"ASC\"") Sort.Direction sortDirection) {
return ApiLogic.freeTextSearch(User.class, userDataManager, userMetaOperations, offset, limit, searchTerm, sortBy, sortDirection);
}
...
}  

```
`freeTextSearch` does not return a list of all matching database records, but rather the contents of a `Page` object. This means that the search results are paginated by definition. Because of this, `freeTextSearch` takes in the 2 arguments `int offset` and `int limit` - in that order. The `offset` must be specified, whereas the `limit` will default to 50. An additional 2 optional arguments are `String sortBy` and `Sort.Direction sortDirection` - in that order. `String sortBy` specifies the name of a field within the given entity by which to apply the sort. If a field name is given yet no matching field is found an `IllegalArgumentException` is thrown. If left blank, it defaults to the 	id	 field. `Sort.Direction sortDirection` determines the ordering strategy (ascending / descending). If not specified it defaults to ascending order (`ASC`).


### Embedded / foreign key Collections
`Iterable<...>` collections are unique in that they are not "assigned" per say - they're **associated with**, **updated in**, and **removed from**. As such, some specialized endpoints are required in order to work with them. In order to expose endpoints for an embedded collection, annotate the field with `@EmbeddedCollectionApi` annotation. This annotation takes in several optional arguments, as follows:
1. `ForeignKeyCollectionResolverType[] resolvers()` - `ForeignKeyCollectionResolverType` is an ENUM comprising three types of embedded collection api endpoints; `ASSOCIATE_WITH, REMOVE_FROM, UPDATE_IN, ALL`.  This arguments delineates which CRUD endpoints should be generated for the embedded collection, and defaults to `ALL` if not specified.
2. `Class<? extends EmbeddedCollectionApiHooks> apiHooks()` - This serves a similar purpose to the `ApiHooks<T>` bean described above. It enables custom business logic to be hooked before and / or after CRUD operations. To use, create a public class which implements the `EmbeddedCollectionApiHooks<T>` interface , and pass in the class type token as the argument for this parameter. The class must be wired into the application context (using `@Component`/`@Service`, etc.). If no such argument is passed, it defaults to a dummy implementation containing no business logic.
3. `boolean associatePreExistingOnly()` - This parameter specifies whether the `ASSOCIATE_WITH` endpoint should ensure that instances being added to the collection are already present in the database. Predictably it defaults to `false`.
4. A more advanced feature is the ability to add spring security annotations to the generated endpoints. For brevities sake I am ommiting the rather extensive list of possibilities but they can be viewed  [here](https://github.com/sanda-dev/apifi/blob/master/src/main/java/dev/sanda/apifi/annotations/EmbeddedCollectionApi.java).

A simple example:
```
@Entity
public class Person {
    @Id
    private String id = UUID.randomUUID().toString();
    private String name;
    private Integer age;
    private String address;
    @OneToMany
    @EmbeddedCollectionApi
    private Set<Hobby> hobbies;
}
```
And a new `Hobby` entity:
```
@Entity
public class Hobby {
    @Id
    private String id = UUID.randomUUID().toString();
    private String title;
    private String description;
}
```
Here is a look at the generated code, method by method:

1. Read collection:
		Read collection is generated by default, with or without the presence of  `@EmbeddedCollectionApi` annotation. This default behavior can be overridden by annotating the corresponding getter with `@GraphQLIgnore` annotation (if there's no getter, annotate the field itself). 
    ```
    @...
	@GraphQLQuery  
	public List<List<Hobby>> hobbies(@GraphQLContext List<Person> input) {  
	  return apiLogic.getEmbeddedCollection(...);  
	}
    ```
    An example query :
    ```
    query hobbiesByPerson{
      persons(offset: 25, limit: 75, sortBy: "title", sortDirection: DESC){
      id
      name
        hobbies{
          id
          title
          description
        }
      }
    }
    ```
    
8. Associate new or pre-existing items to collection:
    ```
	@GraphQLMutation  
	public List<Hobby> associateHobbiesWithPerson(Person owner, List<Hobby> input) {  
	  return apiLogic.associateWithEmbeddedCollection(...);  
	}
    ```
 
 3. Update elements in collection:
    ```
    @GraphQLMutation  
	public List<Hobby> updateHobbiesInPerson(Person owner, List<Hobby> input) {  
	  return apiLogic.updateEmbeddedCollection(...);  
	}
    ```
    
9. Remove elements from collection:
    ```
	@GraphQLMutation  
	public List<Hobby> removeHobbiesFromPerson(Person owner, List<Hobby> input) {  
	  return apiLogic.removeFromEmbeddedCollection(...);  
	}
    ```
	**Note:** This method does *not* actually perform any deletions from the referenced table, but rather merely removes the foreign key references from the host entity. This leaves it up to the developer to use either cascading or the `postRemove` / `preRemove` hooks in `EmbeddedCollectionApiHooks<TEmbedded, T>` if there is a need for actual deletion.

### Spring security integration
Apifi supports full integration with spring security by leveraging the following 6 annotations: [`@Secured`](https://docs.spring.io/spring-security/site/docs/3.2.8.RELEASE/apidocs/org/springframework/security/access/annotation/Secured.html), [`@RolesAllowed`](https://docs.oracle.com/javaee/7/api/javax/annotation/security/RolesAllowed.html), [`@PreAuthorize`](https://docs.spring.io/spring-security/site/docs/4.2.13.BUILD-SNAPSHOT/apidocs/org/springframework/security/access/prepost/PreAuthorize.html), [`@PostAuthorize`](https://docs.spring.io/spring-security/site/docs/4.2.13.BUILD-SNAPSHOT/apidocs/org/springframework/security/access/prepost/PostAuthorize.html), [`@PreFilter`](https://docs.spring.io/spring-security/site/docs/4.2.13.BUILD-SNAPSHOT/apidocs/org/springframework/security/access/prepost/PreFilter.html), and [`@PostFilter`](https://docs.spring.io/spring-security/site/docs/4.2.13.BUILD-SNAPSHOT/apidocs/org/springframework/security/access/prepost/PostFilter.html).

#### Overview
Annotation based security is especially well suited to GraphQL APIs, given that they operate off of a single endpoint. Apifi leverages spring security annotations like this:
```
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface WithServiceLevelSecurity {
    String secured() default "";
    String rolesAllowed() default "";
    String preAuthorize() default "";
    String postAuthorize() default "";
    String preFilter() default "";
    String preFilterTarget() default "";
    String postFilter() default "";
}
```
... and this:
```
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Repeatable(WithMethodLevelSecurityAccumulator.class)
public @interface WithMethodLevelSecurity {
    String secured() default "";
    String rolesAllowed() default "";
    String preAuthorize() default "";
    String postAuthorize() default "";
    String preFilter() default "";
    String preFilterTarget() default "";
    String postFilter() default "";
    CRUDResolvers[] targets();
}
```
At compile time, Apifi parses the string directives and applies the corresponding security annotations to their respective endpoints.  The difference between the first and second annotations above, is that the first is intended to apply at the GraphQLApi service level - meaning the security annotation is not to any specific method but to the Service bean which serves as the GraphQLApi for the CRUD operations of a given entity. This means the annotations apply to ALL the contained methods.

The second annotation is for more granular security configuration. It allows for the placing of security annotations on a target group of methods, delineated by the `CRUDResolvers[] targets();` parameter. recall that `CRUDResolvers` is the set of enum values used to tell `@WithCRUDEndpoints(...)` which GraphQL endpoints to create for the given entity. 

**Note:** Method level security annotations will override class level annotations in the even of a difference in policy.

In a similar vein, embedded collection api endpoints are also securable in much the same manner. The [`@EmbeddedCollectionApi`](https://github.com/sanda-dev/apifi/blob/master/src/main/java/dev/sanda/apifi/annotations/EmbeddedCollectionApi.java) annotations also contains spring security directive parameters. The difference is there is a separate  set of such directives for each type of endpoint (i.e. `ASSOCIATE_WITH, REMOVE_FROM, UPDATE_IN`) as well as Read collection. 

Example:
```
@Entity  
@WithServiceLevelSecurity(rolesAllowed = "ROLE_SYS_ADMIN")  
@WithMethodLevelSecurity(rolesAllowed = "ROLE_SECRETARY", targets = {GET_PAGINATED_BATCH, GET_BY_ID})  
@WithMethodLevelSecurity(rolesAllowed = "ROLE_OFFICE_MANAGER", targets = {CREATE, UPDATE})  
@WithCRUDEndpoints({GET_PAGINATED_BATCH, GET_BY_ID, CREATE, UPDATE})  
public class Person {  
	@Id  
	@GeneratedValue  private Long id;  
	@ApiFindBy(rolesAllowed = "ROLE_USER")  
	private String name;  
	private Integer age;  
	@OneToMany  
	@EmbeddedCollectionApi(postAuthorizeGet = "hasRole(ROLE_ADMIN)", preAuthorizeAssociateWith = "hasRole(ROLE_ADMIN)")  
	private Set<Hobby> hobbies;  
}
```
There's quite a bit going on here so let's break it down before looking at the resulting generated code:
1. `@WithServiceLevelSecurity(rolesAllowed = "ROLE_SYS_ADMIN")` - This will apply a `@RolesAllowed("ROLE_SYS_ADMIN")` annotation to the `PersonGraphQLService` bean.
2. `@WithMethodLevelSecurity(rolesAllowed = "ROLE_SECRETARY", targets = {GET_PAGINATED_BATCH, GET_BY_ID})` - This will apply a `@RolesAllowed("ROLE_SECRETARY")` annotations to the `GET_PAGINATED_BATCH` and `GET_BY_ID` endpoints in `PersonGraphQLService` (effectively overriding the previous class level directive).
3. `@WithMethodLevelSecurity(rolesAllowed = "ROLE_OFFICE_MANAGER", targets = {CREATE, UPDATE})` - This will apply a `@RolesAllowed("ROLE_OFFICE_MANAGER")` annotations to the `CREATE` and `UPDATE` methods in `PersonGraphQLService`.
4. `@ApiFindBy(rolesAllowed = "ROLE_USER")` on the `private String name;` field - This will apply a `@RolesAllowed("ROLE_USER")` annotations to the `findPersonsByName` endpoint in `PersonGraphQLService`.
5. `@EmbeddedCollectionApi(postAuthorizeGet = "hasRole(ROLE_ADMIN)", preAuthorizeAssociateWith = "hasRole(ROLE_SUB_ADMIN)")` on the `private Set<Hobby> hobbies;` field - This will apply a `@PostAuthorize("hasRole(ROLE_ADMIN)")` security annotations on the Read endpoint, and a `@PreAuthorize("hasRole("ROLE_SUB_ADMIN")")`on the `ASSOCIATE_WITH` endpoint.

The resulting code:
```
@Service
@Transactional
@GraphQLApi
@RolesAllowed("ROLE_SYS_ADMIN")
public class PersonGraphQLApiService {
  @Autowired
  private ApiLogic<Person> apiLogic;

  @Autowired
  private DataManager<Person> dataManager;

  @Autowired(
      required = false
  )
  private ApiHooks<Person> apiHooks;

  @Autowired
  private DataManager<Hobby> hobbiesDataManager;

  @Autowired
  private NullEmbeddedCollectionApiHooks hobbiesEmbeddedCollectionApiHooks;

  @PostConstruct
  private void postConstructInit() {
    apiLogic.setApiHooks(apiHooks);
    apiLogic.setDataManager(dataManager);
  }

  @GraphQLQuery
  @RolesAllowed("ROLE_SECRETARY")
  public List<Person> persons(int offset,
      @GraphQLArgument(name = "limit", defaultValue = "50") int limit,
      @GraphQLArgument(name = "sortBy", defaultValue = "id") String sortBy,
      @GraphQLArgument(name = "sortDirection", defaultValue = "\"ASC\"") Sort.Direction sortDirection) {
    return apiLogic.getPaginatedBatch(offset, limit, sortBy, sortDirection);
  }

  @GraphQLQuery
  @RolesAllowed("ROLE_SECRETARY")
  public Person getPersonById(Long input) {
    return apiLogic.getById(input);
  }

  @GraphQLMutation
  @RolesAllowed("ROLE_OFFICE_MANAGER")
  public Person createPerson(Person input) {
    return apiLogic.create(input);
  }

  @GraphQLMutation
  @RolesAllowed("ROLE_OFFICE_MANAGER")
  public Person updatePerson(Person input) {
    return apiLogic.update(input);
  }

  @Batched
  @GraphQLQuery
  @PostAuthorize("hasRole('ROLE_ADMIN')")
  public List<List<Hobby>> hobbies(@GraphQLContext List<Person> input) {
    return apiLogic.getEmbeddedCollection(input, "hobbies", hobbiesEmbeddedCollectionApiHooks, hobbiesDataManager);
  }

  @GraphQLMutation
  @PreAuthorize("hasRole('ROLE_SUB_ADMIN')")
  public List<Hobby> associateHobbiesWithPerson(Person owner, List<Hobby> input) {
    return apiLogic.associateWithEmbeddedCollection(owner, "hobbies", input, hobbiesDataManager, null);
  }

  @GraphQLMutation
  public List<Hobby> updateHobbiesInPerson(Person owner, List<Hobby> input) {
    return apiLogic.updateEmbeddedCollection(owner, hobbiesDataManager, input, null);
  }

  @GraphQLMutation
  public List<Hobby> removeHobbiesFromPerson(Person owner, List<Hobby> input) {
    return apiLogic.removeFromEmbeddedCollection(owner, "hobbies", input, null);
  }

  @GraphQLQuery
  @RolesAllowed("ROLE_USER")
  public List<Person> findPersonsByName(String name) {
    return apiLogic.apiFindBy("name", name);
  }
}
```
The above example also happens to be a good summary of Apifi framework. It demonstrates what a real world use case might look like. 

#### That's all for now, happy coding!
### License
Apache 2.0
