package dev.sanda.apifi.annotations;

import dev.sanda.apifi.code_generator.entity.EntityCollectionEndpointType;
import dev.sanda.apifi.service.api_hooks.EntityCollectionApiHooks;
import dev.sanda.apifi.service.api_hooks.NullEntityCollectionApiHooks;
import dev.sanda.apifi.service.graphql_subcriptions.EntityCollectionSubscriptionEndpoints;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * When placed on a field of type {@code Collection<T>} of a JPA Entity annotated class
 * where {@code T} is also a JPA entity class,
 * and is annotated as either {@code @OneToMany} or {@code @ManyToMany}.
 * This annotation uses {@code EntityCollectionEndpointType} enum
 * value argument options to delineate autogenerated GraphQL resolver methods
 * along with their respective spring security annotations (if required).
 *
 * For example:
 * <pre>{@code
 * @Data
 * @Entity
 * public class User {
 *   @Id @GeneratedValue
 *   private Long id;
 *   @OneToMany
 *   @EntityCollectionApi(
 *     endpoints = {
 *       ASSOCIATE_WITH,
 *       REMOVE_FROM,
 *       UPDATE_IN,
 *       GET_PAGINATED__BATCH,
 *       PAGINATED__FREE_TEXT_SEARCH,
 *     }
 *   )
 *   private Set<Post> posts;
 *   //...
 * }
 * }</pre>
 * Will translate into the following GraphQL query resolvers:
 * <pre>{@Code
 *
 *   @GraphQLMutation
 *   public List<Post> associatePostsWithUser(User owner, List<Post> input) {
 *     return apiLogic.associateWithEntityCollection(...);
 *   }
 *
 *   @GraphQLMutation
 *   public List<Post> updatePostsOfUser(User owner, List<Post> input) {
 *     return apiLogic.updateEntityCollection(...);
 *   }
 *
 *   @GraphQLMutation
 *   public List<Post> removePostsFromUser(User owner, List<Post> input) {
 *     return apiLogic.removeFromEntityCollection(...);
 *   }
 *
 *   @GraphQLQuery
 *   public Page<Post> postsOfUser(User owner, PageRequest input) {
 *     ...
 *     return apiLogic.getPaginatedBatchInEntityCollection(...);
 *   }
 *
 *   @GraphQLQuery
 *   public Page<Post> postsOfUserFreeTextSearch(User owner, FreeTextSearchPageRequest input) {
 *     ...
 *     return apiLogic.paginatedFreeTextSearchInEntityCollection(...);
 *   }
 * }</pre>
 */
@Target({ ElementType.FIELD, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
public @interface EntityCollectionApi {
  Class<? extends EntityCollectionApiHooks> apiHooks() default NullEntityCollectionApiHooks.class;

  /**
   * boolean flag denoting whether or not pre-existing entity instances
   * will be allowed to be added to the given collection via the endpoint
   * generated if the {@code EntityCollectionEndpointType.ASSOCIATE_WITH} value
   * was passed as an argument to {@code endpoints()}
   * */
  boolean associatePreExistingOnly() default false;

  /**
   * Array of {@code EntityCollectionEndpointType} enum values denoting
   * which query resolvers should be autogenerated at compile time.
   */
  EntityCollectionEndpointType[] endpoints();

  /**
   * Array of {@code EntityCollectionSubscriptionEndpoints} enum values denoting
   * which subscription resolvers should be autogenerated at compile time.
   *
   * For example:
   *
   * <pre>{@code
   * @Data
   * @Entity
   * public class User {
   *   @Id @GeneratedValue
   *   private Long id;
   *   @OneToMany
   *   @EntityCollectionApi(
   *         endpoints = {
   *          ASSOCIATE_WITH,
   *          REMOVE_FROM,
   *          UPDATE_IN,
   *          GET_PAGINATED__BATCH,
   *          PAGINATED__FREE_TEXT_SEARCH,
   *        },
   *        subscriptions = { ON_ASSOCIATE_WITH, ON_UPDATE_IN, ON_REMOVE_FROM }
   *   )
   *   private Set<Post> posts;
   *   //...
   * }
   * }</pre>
   * * Will translate into the following GraphQL query resolvers:
   * <pre>{@Code
   *   @GraphQLSubscription
   *   public Flux<List<Post>> onAssociatePostsWithUser(...) {
   *     return apiLogic.onAssociateWithSubscription(...);
   *   }
   *
   *
   *   @GraphQLSubscription
   *   public Flux<List<Post>> onRemovePostsFromUser(...) {
   *     return apiLogic.onRemoveFromSubscription(...);
   *   }
   *}</pre>
   */
  EntityCollectionSubscriptionEndpoints[] subscriptions() default EntityCollectionSubscriptionEndpoints.NONE;

  String[] freeTextSearchFields() default "";

  /**
   * spring security annotations denoting
   * authorization policies with respect to
   * the autogenerated query resolver methods
   */
  String secured() default "";

  String[] rolesAllowed() default "";

  String preAuthorize() default "";

  String postAuthorize() default "";

  String preFilter() default "";

  String preFilterTarget() default "";

  String postFilter() default "";

  /**
   * spring security annotations denoting
   * authorization policies  to the autogenerated
   * query resolver method delineated in
   * the {@code GET_PAGINATED__BATCH} argument (if) passed to {@code endpoints()}
   */
  String securedGetPaginated() default "";

  String[] rolesAllowedGetPaginated() default "";

  String preAuthorizeGetPaginated() default "";

  String postAuthorizeGetPaginated() default "";

  String preFilterGetPaginated() default "";

  String preFilterTargetGetPaginated() default "";

  String postFilterGetPaginated() default "";

  /**
   * spring security annotations denoting
   * authorization policies  to the autogenerated
   * query resolver method delineated in
   * the {@code PAGINATED__FREE_TEXT_SEARCH} argument (if) passed to {@code endpoints()}
   */
  String securedPaginatedFreeTextSearch() default "";

  String[] rolesAllowedPaginatedFreeTextSearch() default "";

  String preAuthorizePaginatedFreeTextSearch() default "";

  String postAuthorizePaginatedFreeTextSearch() default "";

  String preFilterPaginatedFreeTextSearch() default "";

  String preFilterTargetPaginatedFreeTextSearch() default "";

  String postFilterPaginatedFreeTextSearch() default "";

  /**
   * spring security annotations denoting
   * authorization policies  to the autogenerated
   * query resolver method generated for batched
   * data loading of the given collection.
   */
  String securedGet() default "";

  String[] rolesAllowedGet() default "";

  String preAuthorizeGet() default "";

  String postAuthorizeGet() default "";

  String preFilterGet() default "";

  String preFilterTargetGet() default "";

  String postFilterGet() default "";

  /**
   * spring security annotations denoting
   * authorization policies  to the autogenerated
   * query resolver method delineated in
   * the {@code ASSOCIATE_WITH} argument (if) passed to {@code endpoints()}
   */
  String securedAssociateWith() default "";

  String[] rolesAllowedAssociateWith() default "";

  String preAuthorizeAssociateWith() default "";

  String postAuthorizeAssociateWith() default "";

  String preFilterAssociateWith() default "";

  String preFilterTargetAssociateWith() default "";

  String postFilterAssociateWith() default "";

  /**
   * spring security annotations denoting
   * authorization policies  to the autogenerated
   * query resolver method delineated in
   * the {@code REMOVE_FROM} argument (if) passed to {@code endpoints()}
   */
  String securedRemoveFrom() default "";

  String[] rolesAllowedRemoveFrom() default "";

  String preAuthorizeRemoveFrom() default "";

  String postAuthorizeRemoveFrom() default "";

  String preFilterRemoveFrom() default "";

  String preFilterTargetRemoveFrom() default "";

  String postFilterRemoveFrom() default "";

  /**
   * spring security annotations denoting
   * authorization policies  to the autogenerated
   * subscription resolver method delineated in
   * the {@code ON_ASSOCIATE_WITH} argument (if) passed to {@code subscriptions()}
   */
  String securedOnAssociateWith() default "";

  String[] rolesAllowedOnAssociateWith() default "";

  String preAuthorizeOnAssociateWith() default "";

  String postAuthorizeOnAssociateWith() default "";

  String preFilterOnAssociateWith() default "";

  String preFilterTargetOnAssociateWith() default "";

  String postFilterOnAssociateWith() default "";

  /**
   * spring security annotations denoting
   * authorization policies  to the autogenerated
   * subscription resolver method delineated in
   * the {@code ON_REMOVE_FROM} argument (if) passed to {@code subscriptions()}
   */
  String securedOnRemoveFrom() default "";

  String[] rolesAllowedOnRemoveFrom() default "";

  String preAuthorizeOnRemoveFrom() default "";

  String postAuthorizeOnRemoveFrom() default "";

  String preFilterOnRemoveFrom() default "";

  String preFilterTargetOnRemoveFrom() default "";

  String postFilterOnRemoveFrom() default "";
}
