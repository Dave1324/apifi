# Apifi

* [Introduction](#introduction)
* [Installation](#installation)
* [Requirements](#requirements)
* [Hello World](#hello-world)
    * [Domain model](#domain-model)
    * [Service layer](#service-layer)
* [The standard CRUD schema](#the-standard-crud-schema)
* [Entity level API configuration](#entity-level-api-configuration)
* [Custom resolvers](#custom-resolvers)
* [Free text search](#free-text-search)
	* [Overview](#overview)
	* [Domain model](#domain-model-1)
	* [Generated Service Layer](#generated-service-layer)
* [Collections](#collections)
* [ApiMetaOperations<T>](#apimetaoperations-t-)
* [EmbeddedCollectionMetaOperations](#embeddedcollectionmetaoperations)
* [@Secure(...) - Spring security integration](#-withSecurity-----spring-security-integration)
    * [Overview](#overview-1)
* [License](#license)

## Introduction
The [Datafi](https://github.com/sindaryn/datafi) library fully automates the generation and use of data access layer code, abstracting away the need for directly dealing with any `JpaRepository`. Apifi takes it to the next level by abstracting away the need to code the service or controller layers. The only thing required for the automatic generation of a full-fledged API, is a correctly annotated data model. This guide assumes the reader has a basic understanding of GraphQL schemas and APIs.

### Installation

Apifi is available on maven central:
```
<dependency>
  <groupId>org.sindaryn</groupId>
    <artifactId>apify</artifactId>
  <version>0.0.2</version>
</dependency>   
```
### Requirement
All entities **must** have a public `getId()` method.

### Hello World
Apifi autogenerates GraphQL Service beans, containing all requisite queries and resolvers for data model entities annotated with `@Entity` and / or `@Table`.
#### Domain model
```
@Entity

public class Person{
    @Id
    private String id = UUID.randomUUID().toString();
    private String name;
    private Integer age;
    // getters & setters, etc...
}
```
#### Service layer
After compiling the project and taking a peek in the "target" folder, the following is the autogenerated GrappQL service:
```
@Service
@Transactional
@GraphQLApi
public class PersonGraphQLService {

  /* ... various injected dependencies ... */ 
  
  @GraphQLQuery
  public List<Person> allPersons(int limit, int offset) {
    return ApiLogic.getAll(personDataManager, limit, offset);
  }

  @GraphQLQuery
  public Person getPersonById(String input) {
    return ApiLogic.getById(personDataManager,input);
  }

  @GraphQLQuery
  public List<Person> getPersonsById(List<String> input) {
    return ApiLogic.getCollectionById(personDataManager, input);
  }

  @GraphQLMutation
  public Person addPerson(Person input) {
    Person entity = ApiLogic.add(personDataManager, input, personMetaOperations);
    return entity;
  }

  @GraphQLMutation
  public Person updatePerson(Person input) {
    Person entity = ApiLogic.update(personDataManager, input, reflectionCache, personMetaOperations);
    return entity;
  }

  @GraphQLMutation
  public Person deletePerson(Person input) {
    Person entity = ApiLogic.delete(personDataManager, reflectionCache, input, personMetaOperations);
    return entity;
  }

  @GraphQLMutation
  public List<Person> addPersons(List<Person> input) {
    List<Person> entities = ApiLogic.addCollection(personDataManager, input, personMetaOperations);
    return entities;
  }

  @GraphQLMutation
  public List<Person> updatePersons(List<Person> input) {
    List<Person> entities = ApiLogic.updateCollection(personDataManager, input, personMetaOperations);
    return entities;
  }

  @GraphQLMutation
  public List<Person> deletePersons(List<Person> input) {
    List<Person> entities = ApiLogic.deleteCollection(personDataManager, input, personMetaOperations);
    return entities;
  }
}
```
The Service bean is named by appending the String "GraphQLService" to the pascal case name of the given entity - hence "PersonGraphQLService". 
As you can see, there are three annotations on the class: 
- `@Service`: Tells Spring to include it in the application context. 
- `@Transactional`: Tells Jpa that database operations happen within retractable transactions.
- `@GraphQLApi`: Tells the [SPQR](https://github.com/leangen/graphql-spqr) Java-GraphQL framework (upon which this project heavily relies), to expose the contained queries and resolvers at the `/graphql` endpoint.

    _**Important note:**_ _As mentioned, the default endpoint is `/graphql`, however this can be customized by setting the `graphql.spqr.http.endpoint=YOUR_CUSTOM_ENDPOINT_HERE` property in the `application.properties` / `application.yml` / other configuration source._

### The standard CRUD schema
As in the above example, the standard, baseline graphql schema which is autogenerated contains the following GraphQL resolvers:
1. `all...`
    
    ```
    @GraphQLQuery
      public List<Person> allPersons(
	  @GraphQLArgument(name = "offset", defaultValue = "0") int offset,
      @GraphQLArgument(name = "limit", defaultValue = "50") int limit,
      @GraphQLArgument(name = "sortBy") String sortBy,
      @GraphQLArgument(name = "sortDirection", defaultValue = "\"ASC\"") Sort.Direction sortDirection) {
        return ApiLogic.getAll(personDataManager, limit, offset);
      }
   ```
    **Input**: 
      - `int limit, int offset` : the result of `all...` is paginated. These arguments specify the page offset and size. If not specified, the first 50 records will be returned.
	  - `String sortBy, Sort.Direction sortDirection`: The first argument specifies the name of a field within the given entity type by which to sort the results (if no such field exists an `IllegalArgumentException` is thrown), the second argument specifies whether this sort is to be applied in ascending (`ASC`) or descending (`DESC`) order. If the `String sortBy` argument is provided but the `Sort.Direction sortDirection` argument is not, the sort will be applied in ascending order.

 **Output**: `(limit - offset)` entity instances, either sorted or not, depending on the arguments provided.
    
2. `get...ById`
    
    ```
      @GraphQLQuery
      public Person getPersonById(String input) {
        return ApiLogic.getById(personDataManager,input);
      }
   ```
    **Input**: The id value by which to find the required entity instance.
    **Output**: The required entity instance.
    
3. `get...sById`
    ```
      @GraphQLQuery
      public List<Person> getPersonsById(List<String> input) {
        return ApiLogic.getCollectionById(personDataManager, input);
      }
   ```
    **Input**: The id values by which to find the required entity instances.
    **Output**: The required entity instances.
    
4. `add...`
    ```
      @GraphQLMutation
      public Person addPerson(Person input) {
        Person entity = ApiLogic.add(personDataManager, input, personMetaOperations);
        return entity;
      }
   ```
    **Input**: An entity to add to the database.
    **Output**: The newly added entity.
    
5. `update...`
    ```
      @GraphQLMutation
      public Person updatePerson(Person input) {
        Person entity = ApiLogic.update(personDataManager, input, reflectionCache, personMetaOperations);
        return entity;
      }
   ```
    **Input**: An entity "instance" with updated values with which to assign / overwrite the corresponding values of the entity with the same id.
    **Output**: The newly updated entity.

    **_Important note:_** _This update relies on the `cascadeUpdate(...)` method defined in `DataManager<T>` which reflectively iterates over all fields of the object to update and assigns them to the the corresponding values within the updated object passed as the second argument. Any field can be excluded from this kind of update by being annotated as `@NonApiUpdatable`._
    
6. `delete...`
    ```
      @GraphQLMutation
      public Person deletePerson(Person input) {
        Person entity = ApiLogic.delete(personDataManager, reflectionCache, input, personMetaOperations);
        return entity;
      }
   ```
    **Input**: An entity instance containing a valid id.
    **Output**: The newly deleted entity.
    
7. `add...s`
    ```
        @GraphQLMutation
        public List<Person> addPersons(List<Person> input) {
        List<Person> entities = ApiLogic.addCollection(personDataManager, input, personMetaOperations);
        return entities;
      }
   ```
    **Input**: A list of entities to add to the database.
    **Output**: The newly added entities.
    
8. `update...s`
    ```
      @GraphQLMutation
      public List<Person> updatePersons(List<Person> input) {
        List<Person> entities = ApiLogic.updateCollection(personDataManager, input, personMetaOperations);
        return entities;
      }
   ```
    **Input**: A list of entities to update.
    **Output**: The newly updated entities.

    **_Important note:_** _This update relies on the `cascadeUpdateCollection(...)` method defined in `DataManager<T>` which reflectively iterates over all fields of every object to update and assigns them to the the corresponding values within the corresponding updated object passed in as input. Any field can be excluded from this kind of update by being annotated as `@NonApiUpdatable`._
    
9. `delete...s`
    ```
      @GraphQLMutation
      public List<Person> deletePersons(List<Person> input) {
        List<Person> entities = ApiLogic.deleteCollection(personDataManager, input, personMetaOperations);
        return entities;
      }
   ```
    **Input**: A list of entities to delete.
    **Output**: The newly deleted entities.
    
### Entity level API configuration
By default, Apifi generates one of these service beans for all entities / tables. There are however several entity level annotations which can modilfy or extend this default behavior:

1. `@NonDirectlyExposable`: Tells Apifi that this is an entity which should **not** have it's own top-level queries and mutations exposed as part of the api schema. This is useful if for example,  we have two entities; `Car` and `SteeringWheel`. It's fairly obvious that in this case the **composite entity** called `SteeringWheel` has no independent lifecycle and is instantiable only within the context of `Car`. In this case, `Car` should be exposed directly as part of the schema, as opposed to `SteeringWheel`, which should be accessable and mutatable only by way of the queries and resolvers exposed by the `Car` graphql service.

2. `@ApiReadOnly`:  Assuming the previous annotation is **not** present, this annotation tells Apifi to only include GraphQL queries but not mutations in the generated GraphQLService bean. This is useful when designating certain components of a given data model as read-only, with no possibility of state mutation via the API.

3. `@ApiHooksAndCustomResolvers{Class<? extends ApiMetaOperations> value();}`: Often times, additional logical operations are required before and / or after the execution of a resolvers base CRUD logic. For example: Given a SaaS application onboarding system, which onboards `Tenant` entities. Assuming each tenant (e.g. company) requires its own unique subdomain, the relevant DNS registrars API should be called immediately following the initial onboarding. `ApiMetaOperations<T>` is the abstract base class which can be extended and passed in as an argument to this annotation in order to achieve this. We'll get into it in more depth a bit further on.

### Custom resolvers 

In addition to the standard CRUD operation resolvers, custom resolvers can be added by making use of the following annotations:
-  `@GetBy`: To fetch a list of entity instances with the search criteria being the value of a specific field, the field can be annotated with the `@GetBy` annotation and a custom `List<...> get...By...(field value as arg)` resolver will be added to the GraphQL service bean. For example: 
    ```
    @Entity
    public class Person {
        @Id
        private String id = UUID.randomUUID().toString();
        private String name;
        @GetBy
        private Integer age;
        private String address;
    }
    ```
    The above `@GetBy` would generate the following resolver:
    ```
    @...
    PersonGraphQLService{
    ...
      //fetch a list of people who are "age" years old
      @GraphQLQuery
      public List<Person> getPersonsByAge(Integer age) {
        return ApiLogic.getBy(personDataManager, "age", age);
      }
    ...
    }
    ```
-  `@GetAllBy`: To fetch a list of entity instances with the search criteria being the value of a specific field being contained within a list of corresponding inputted values, the field can be annotated with the `@GetAllBy` annotation and a custom `List<...> getAll...By...(list of field values to look for)` resolver will be added to the GraphQL service bean. For example:
    ```
    @Entity
    
    public class Person {
        @Id
        private String id = UUID.randomUUID().toString();
        @GetAllBy
        private String name;
        private Integer age;
        private String address;
    }
    ```
    The above `@GetAllBy` would generate the following resolver:
    ```
    @...
    PersonGraphQLService{
    ...
      //fetch a list of people whos name is included in the "names" list
      @GraphQLQuery
      public List<Person> getAllPersonsByNames(List<String> names) {
        return ApiLogic.getAllBy(personDataManager, "name", names);
      }
    ...
    }
    ```
-  `@GetByUnique`: To fetch a _single_ entity instance by the value of a unique field, the field can be annotated with the `@GetByUnique` annotation and a custom `get...ByUnique...(field value)` resolver will be added to the GraphQL service bean. For example:
    ```
    @Entity
    
    public class Person {
        @Id
        private String id = UUID.randomUUID().toString();
        private String name;
        private Integer age;
        private String address;
        @Column(unique = true) @GetByUnique
        private String socialSecurityNumber;
    }
    ```
    The above `@GetByUnique` would generate the following resolver:
    ```
    @...
    PersonGraphQLService{
      ...
      @GraphQLQuery
      public Person getPersonBySocialSecurityNumber(String socialSecurityNumber) {
        return ApiLogic.getByUnique(personDataManager, "socialSecurityNumber", socialSecurityNumber);
      }
    ...
    }
    ```
-  `@WithResolver(...)`: To fetch a list of entity instances using a custom JPQL query, the relevant entity-class can be annotated  with the `@WithResolver(...)` annotation and a corresponding resolver will be added to the GraphQL service bean. The `@WithResolver(...)` annotation feature is a bit more involved than the others, and builds upon it's implementation in the [Datafi](https://github.com/sindaryn/datafi) library. If you are unfamiliar with it's usage, head on over to the Datafi [Readme](https://github.com/sindaryn/datafi/blob/master/README.md). As is the case with the previous three annotations, Apifi extends the functionality provided by [Datafi](https://github.com/sindaryn/datafi) by generating the code required to expose that data layer resolver to the web. 
    
    In any event, here is an example of `@WithResolver` usage:
    ```
    @Entity
    
    @WithResolver(name = "getPersonsByNameOrAge", where = "p.name = :name OR p.age = :age", args = {"name", "age"})
    public class Person {
        @Id
        private String id = UUID.randomUUID().toString();
        private String name;
        private Integer age;
        private String address;
    }
    ```
    The above `@WithResolver(...)` would generate the following resolver:
    ```
    @...
    PersonGraphQLService{
    ...
      @GraphQLQuery
      public List<Person> getPersonsByNameOrAge(String name, Integer age) {
        List<Object> args = Arrays.asList(name, age);
        return ApiLogic.selectBy(personDataManager, "getPersonsByNameOrAge", args);
      }
    ...
    }
    ```
    Important note: `@WithResolver(...)` is a repeatable annotation, therefore as many custom JPQL query based resolvers per class may be assigned as needed.

### Free text search

##### Overview

Apifi comes with non case sensitive free text - or "fuzzy" search out of the box. This extends and relies upon the [free text search feature in Datafi](https://github.com/sindaryn/datafi#free-text-search). To make use of this feature, annotate any **String typed** field with `@FuzzySearchBy`, or alternatively, annotate the class itself with `@FuzzySearchByFields({"field1", "field2", etc...})`. For example:

##### Domain model  
```  
@Entity
//@FuzzySearchByFields({"name", "email"}) - this is equivalent to the field level annotations below
public class Person{  

@Id 
private String id = UUID.randomUUID().toString(); 

@FuzzySearchBy
private String name;
@FuzzySearchBy
private String email;
//...
}  
```  

##### Generated Service Layer  
```  
@...  
public class PersonGraphQLService{  
...
@GraphQLQuery
public List<User> personsFuzzySearch(String searchTerm, //in this case can be either (partial or complete) name  or email
@GraphQLArgument(name = "offset", defaultValue = "0") int offset,
@GraphQLArgument(name = "limit", defaultValue = "50") int limit,
@GraphQLArgument(name = "sortBy") String sortBy,
@GraphQLArgument(name = "sortDirection", defaultValue = "\"ASC\"") Sort.Direction sortDirection) {
return ApiLogic.fuzzySearch(User.class, userDataManager, userMetaOperations, offset, limit, searchTerm, sortBy, sortDirection);
}
...
}  

```
`fuzzySearch` does not return a list of all matching database records, but rather the contents of a `Page` object. This means that the search results are paginated by definition. Because of this, `fuzzySearch` takes in the 2 optional arguments `int offset` and `int limit` - in that order. These are "optional" in the sense that if not specified, the offset and limit will default to 0 and 50 respectively. An additional 2 optional arguments are `String sortBy` and `Sort.Direction sortDirection` - in that order. `String sortBy` specifies the name of a field within the given entity by which to apply the sort. If no matching field is found an `IllegalArgumentException` is thrown. `Sort.Direction sortDirection` determines the ordering strategy. If not specified it defaults to ascending order (`ASC`).


### Collections
`Iterable<...>` collections are unique in that they are not "assigned" per say - they're **added to**, **updated in**, and **removed from**. As such, some specialized resolvers are required in order to work with them. Before we can demonstrate these, we'll need to add a collection to our example. Fortunately, our `Person` appears to have picked up a few hobbies!

```
@Entity

public class Person {
    @Id
    private String id = UUID.randomUUID().toString();
    private String name;
    private Integer age;
    private String address;
    @OneToMany
    private Set<Hobby> hobbies;
}
```
And our new `Hobby` entity:
```
@Entity
(exposeDirectly = false)
public class Hobby {
    @Id
    private String id = UUID.randomUUID().toString();
    private String title;
    private String description;
}
```
Let's have a look at the generated code, method by method:

1. Read collection:
    ```
    @GraphQLQuery
    public List<List<Hobby>> hobbies(@GraphQLContext List<Person> input) {
    return ApiLogic.getAsEmbeddedCollection(...);
    }
    ```
    This query resolver allows graphql queries such as the following to be executed :
    ```
    query getHobbiesOfPersons{
      allPersons(offset: 0, limit: 75, sortBy: "title", sortDirection: DESC){
      ...
        hobbies{
          id
          title
          description
        }
      ...
      }
    }
    ```
    This should look familiar to anyone with a working knowledge of GraphQL. It's the typical way you'd expect to retreive a foreign key collection.
    
2. Add / attach to collection:
    ```
    @GraphQLMutation
    public List<Hobby> addNewHobbiesToPerson(List<Hobby> input, Person person) {
        return ApiLogic.addNewToEmbeddedCollection(...);
    }
    ```
    This mutation accepts two arguments:
     - `List<...> input`: The entities - in this case; hobbies, to add the the given person. Recall the `@NonDirectlyExposable` annotation. If the type of entity referenced in the given collection is annotated as such - and therefore has no independent lifecycle, it makes sense to create new instances within the context of an embedded collection within a host Aggregate entity. In this instance hobby is not marked for direct API exposure, hence the `addNewHobbiesToPerson` resolver, and not the `attachExisting...To...` equivalent resolver for cases where the referenced entity type has its own top level queries and mutations exposed. 
     - `Person person`: The host entity which the collection in question belongs to. The (deserialized) instance passed to this argument must include the `id`.
      
 
 3. Update elements in collection:
    ```
      @GraphQLMutation
      public List<Hobby> updateHobbiesInPerson(List<Hobby> input, Person person) {
        return ApiLogic.updateEmbeddedCollection(...);
      }
    ```
    Accepts two arguments following a similar concept as the previous mutation - a list of elements to be updated, and a reference to the host entity. The method makes use of application-level "cascading", therefore obviating the need to worry about database-level cascading on update operations.
    
4. Remove elements from collection:
    ```
      @GraphQLMutation
      public List<Hobby> removeHobbiesFromPerson(List<Hobby> input, Person person) {
        return ApiLogic.removeFromEmbeddedCollection(...);
      }
    ```
    Accepts two arguments following a similar concept as the previous two mutations - a list of elements to be removed, and a reference to the host entity. Note that this method does NOT actually perform any deletions, but rather merely removes the foreign key references.

### ApiMetaOperations<T>
As briefly mentioned above, Apifi APIs are designed for extensibility. This is where `ApiMetaOperations<T>` comes in. To get a better understanding as to how this works, let's take a peek into the `ApiLogic` interface where we keep our actual api-level logic - or more the specifically the `addCollection` method:

```
    static <T, E extends ApiMetaOperations<T>> List<T>
    addCollection(DataManager<T> dataManager, List<T> input, E apiHooks) {
        apiHooks.preAddEntities(input);
        val result = dataManager.saveAll(input);
        apiHooks.postAddEntities(result);
        return result;
    }
```
Note the two lines `apiHooks.preAddEntities(input);`, and `apiHooks.postAddEntities(result);`. These method calls allow for the `apiHooks` instance which was passed as an argument to execute custom defined logic before and / or after the core logic. This pattern repeats itself in the same manner in all of the other `ApiLogic` methods, allowing for the execution of custom defined logic prior to or following mutations and queries.

In order to make use of this, the class type token of the developers custom child-class of `ApiMetaOperations<T>` must be passed as an argument to the `@ApiHooksAndCustomResolvers(...)` annotation. In order to understand how to make practical use of this feature, observe the `ApiMetaOperations<T>` source code:
```
@Component
public class ApiMetaOperations<T> {

    //don't worry about these
    @Autowired
    protected ReflectionCache reflectionCache;
    @Autowired
    protected DataManager<T> dataManager;

    //queries
    public void preFetchEntityInGetById(Object id){}
    public void preFetchEntityInGetByUnique(Object argument){}
    public void preFetchEntityInGetBy(Object argument){}
    public void preFetchEntityInGetAllBy(List<?> arguments){}
    public void preFetchEntityInCustomResolver(List<?> arguments){}
    public void preFetchEntitiesInGetAll(Class<T> clazz) {}
    public void preFetchEntitiesInFuzzySearch(Class<T> clazz, String searchTerm){}
    public void postFetchEntitiesInFuzzySearch(Class<T> clazz, String searchTerm, List<T> fetched){}
    public void postFetchEntity(T fetched){}
    public void postFetchEntities(Collection<T> fetched){fetched.forEach(this::postFetchEntity);}

    //mutations
    public void preAddEntity(T toAdd){}
    public void postAddEntity(T added){}
    public void preUpdateEntity(T toUpdate){}
    public void postUpdateEntity(T toUpdate){}
    public void preDeleteEntity(T toDelete){}
    public void postDeleteEntity(T deleted){}
    public void preArchiveEntity(T toArchive){}
    public void postArchiveEntity(T toArchive){}
    public void preDeArchiveEntity(T toDeArchive){}
    public void postDeArchiveEntity(T toDeArchive){}

    public void preAddEntities(Collection<T> toAdd){toAdd.forEach(this::preAddEntity);}
    public void postAddEntities(Collection<T> added){added.forEach(this::postAddEntity);}
    public void preUpdateEntities(Collection<T> toUpdate){toUpdate.forEach(this::preUpdateEntity);}
    public void postUpdateEntities(Collection<T> toUpdate){toUpdate.forEach(this::postUpdateEntity);}
    public void preDeleteEntities(Collection<T> toDelete){toDelete.forEach(this::preDeleteEntity);}
    public void postDeleteEntities(Collection<T> deleted){deleted.forEach(this::postDeleteEntity);}
    public void preArchiveEntities(Collection<T> toArchive){toArchive.forEach(this::preArchiveEntity);}
    public void postArchiveEntities(Collection<T> toArchive){toArchive.forEach(this::postArchiveEntity);}
    public void preDeArchiveEntities(List<T> toDeArchive){toDeArchive.forEach(this::preDeArchiveEntity);}
    public void postDeArchiveEntities(List<T> toDeArchive){toDeArchive.forEach(this::postDeArchiveEntity);}
}
```
The methods and code are fairly self-explanatory. As is observable, the default `ApiMetaOperations<T>` class which is passed as that third argument to `GraphQLApiEntity` has no actual impact. To override this default behaviour (or lack thereof), the base class must be extended and implemented as required. Let's go through a familiar example. Given our `Person` entity:
```
@Entity

public class Person{
    @Id
    private String id = UUID.randomUUID().toString();
    private String name;
    private Integer age;
    // getters & setters, etc...
}
```
Assume there is a requirement to print a welcome message to the console after every time a new person is added, and a goodbye message after every time a person is deleted. To do so, a custom implementation of `ApiMetaOperations<T>` can be implemented as follows:
```
@Component
public class PersonMetaOperations extends ApiMetaOperations<Person> {

    @Override
    public void postAddEntity(Person added) {
        System.out.println("Hello " + added.getName() + "!");
    }

    @Override
    public void postDeleteEntity(Person deleted) {
        System.out.println("Goodbye " + deleted.getName() + ":(");
    }
    
}
```
The final step is to pass the corresponding class type token as an argument to the `@ApiHooksAndCustomResolvers` annotation on `Person`:
```
@Entity
@ApiHooksAndCustomResolvers(PersonMetaOperations.class)
public class Person{
    @Id
    private String id = UUID.randomUUID().toString();
    private String name;
    private Integer age;
    // getters & setters, etc...
}
```
The required custom behaviour is now fully defined and operational. Obviously this is a trivial example, but the same workflow applies to more complex use cases such as third party API calls, data related metrics, etc.

### EmbeddedCollectionMetaOperations
As demostrated above, embedded collections must be dealt with in their own way. This is why the standard `ApiMetaOperations<T>` cannot apply to mutations performed on embedded collections. In order to add custom pre or post mutation logic to embedded collection related api mutations, the collection in question must first be annotated with the `@MetaOperations(...)` annotation, as follows:
```
@Entity
(apiMetaOperations = PersonMetaOperations.class)
public class Person{
    @Id
    private String id = UUID.randomUUID().toString();
    private String name;
    private Integer age;
    @ManyToMany
    @MetaOperations(...)
    private Set<Person> friends;
}
```
Next, the `EmbeddedCollectionMetaOperations<T, HasTs>` base class must be extended. The base `EmbeddedCollectionMetaOperations<T, HasTs>` class looks as follows:

```
@Component
public class EmbeddedCollectionMetaOperations<T, HasTs>{
    
    @Autowired @Getter
    private ReflectionCache reflectionCache;
    @Autowired @Getter
    private DataManager<T> tDataManager;
    @Autowired @Getter
    private DataManager<HasTs> hasTsDataManager;

    public void postFetch(Collection<T> Ts, HasTs hasTs){}
    public void preRemove(Collection<T> Ts, HasTs hasTs){}
    public void postRemove(Collection<T> Ts, HasTs hasTs){}
    public void preAttachOrAdd(Collection<T> Ts, HasTs hasTs){}
    public void postAttachOrAdd(Collection<T> Ts, HasTs hasTs){}
    public void preUpdate(Collection<T> Ts, HasTs hasTs){}
    public void postUpdate(Collection<T> Ts, HasTs hasTs){}
}
```
The code above should also be fairly self explanatory. To illustrate, let's implement a child class which prints the name of each newly added hobby:

```
@Component
public class HobbiesInPersonMetaOperations extends EmbeddedCollectionMetaOperations<Hobby, Person> {
    
    @Override
    public void preAttachOrAdd(Collection<Hobby> hobbies, Person person) {
        hobbies.forEach(newHobby -> System.out.println(newHobby.getDescription()));
    }
    
}
```
Finally, the class type token for `HobbiesInPersonMetaOperations` must be passed as an argument to the `@MetaOperation(...)` annotation on the `Set<Hobby> hobbies` collection within `Person`:

```
@Entity
public class Person{
    @Id
    private String id = UUID.randomUUID().toString();
    private String name;
    private Integer age;
    @ManyToMany
    @MetaOperations(apiHooks = HobbiesInPersonMetaOperations.class)
    private Set<Hobby> hobbies;
}
```
### Spring security integration
Apifi supports full integration with spring security - or more specifically; spring security annotations. This is feature can be utilized via the`@Secure(...)` annotation. This annotation can be applied on the class or field level.

#### Overview
Here's how the `@Secure` annotation looks under the hood:
```
@Target({ElementType.FIELD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface Secure {
    String secured() default "";
    String rolesAllowed() default "";
    String preAuthorize() default "";
    String postAuthorize() default "";
    String preFilter() default "";
    String preFilterTarget() default "";
    String postFilter() default "";

    String securedCreate() default "";
    String rolesAllowedCreate() default "";
    String preAuthorizeCreate() default "";
    String postAuthorizeCreate() default "";
    String preFilterCreate() default "";
    String preFilterTargetCreate() default "";
    String postFilterCreate() default "";

    String securedRead() default "";
    String rolesAllowedRead() default "";
    String preAuthorizeRead() default "";
    String postAuthorizeRead() default "";
    String preFilterRead() default "";
    String preFilterTargetRead() default "";
    String postFilterRead() default "";

    String securedUpdate() default "";
    String rolesAllowedUpdate() default "";
    String preAuthorizeUpdate() default "";
    String postAuthorizeUpdate() default "";
    String preFilterUpdate() default "";
    String preFilterTargetUpdate() default "";
    String postFilterUpdate() default "";

    String securedDelete() default "";
    String rolesAllowedDelete() default "";
    String preAuthorizeDelete() default "";
    String postAuthorizeDelete() default "";
    String preFilterDelete() default "";
    String preFilterTargetDelete() default "";
    String postFilterDelete() default "";
}
```
`@Secure` enables the application of any or all of 6 spring & javax security annotations: [`@Secured`](https://docs.spring.io/spring-security/site/docs/3.2.8.RELEASE/apidocs/org/springframework/security/access/annotation/Secured.html), [`@RolesAllowed`](https://docs.oracle.com/javaee/7/api/javax/annotation/security/RolesAllowed.html), [`@PreAuthorize`](https://docs.spring.io/spring-security/site/docs/4.2.13.BUILD-SNAPSHOT/apidocs/org/springframework/security/access/prepost/PreAuthorize.html), [`@PostAuthorize`](https://docs.spring.io/spring-security/site/docs/4.2.13.BUILD-SNAPSHOT/apidocs/org/springframework/security/access/prepost/PostAuthorize.html), [`@PreFilter`](https://docs.spring.io/spring-security/site/docs/4.2.13.BUILD-SNAPSHOT/apidocs/org/springframework/security/access/prepost/PreFilter.html), and [`@PostFilter`](https://docs.spring.io/spring-security/site/docs/4.2.13.BUILD-SNAPSHOT/apidocs/org/springframework/security/access/prepost/PostFilter.html).

Let's get specific with an example:

```
@Entity
@Secure(rolesAllowed = "ROLE_ADMIN")
public class Person {
    @Id
    private String id = UUID.randomUUID().toString();
    private String name;
    private Integer age;
    private String address;
}
```
Here's the resulting service bean:
```
@...
@RolesAllowed("ROLE_ADMIN")
public class PersonGraphQLService {...}
```
Note the `@RolesAllowed("ROLE_ADMIN")` annotation. We now have spring security ensuring that only users which spring security recognizes as having "ROLE_ADMIN" will be able to access and execute any of the contained methods. 

**Importnant note:** This does **not** preconfigure spring security itself, but rather merely applies spring security annotations. The final security setup is up to the developer. 

Oftentimes, more granular control over which methods can be accessed and executed by which users is required, and just slapping on a class level security annotation won't cut it. The automated application of spring security annotations to classes and methods falls into one of two categories:
1. Annotation parameters that were passed as arguments to the class level `@Secure(...)` annotation (as in the above example). These annotations fall into one of 5 sub-categories:
    - CRUD: 
        ```
        @...
        public @interface Secure {
            String secured() default "";
            String rolesAllowed() default "";
            String preAuthorize() default "";
            String postAuthorize() default "";
            String preFilter() default "";
            String preFilterTarget() default "";
            String postFilter() default "";
            ...
        }
        ```
        Note these top-most annotation arguments are named after their corresponding security annotations with **no suffix**. They correspond to the annotations that are placed at the class level - as with our above example.
        
    - Create:
       ```
        @...
        public @interface Secure {
            ...
            String securedCreate() default "";
            String rolesAllowedCreate() default "";
            String preAuthorizeCreate() default "";
            String postAuthorizeCreate() default "";
            String preFilterCreate() default "";
            String preFilterTargetCreate() default "";
            String postFilterCreate() default "";
            ...
        }
        ```
        As is the case with all of the following sub-categories as well, these annotations are for application at the method level. More specifically, they are applicable to _create_ methods - i.e. `add...` and `add...s`.
        
    - Read:
        ```
        @...
        public @interface Secure {
            ...
            String securedRead() default "";
            String rolesAllowedRead() default "";
            String preAuthorizeRead() default "";
            String postAuthorizeRead() default "";
            String preFilterRead() default "";
            String preFilterTargetRead() default "";
            String postFilterRead() default "";
            ...
        }
        ```
        As their suffixes suggest, these are applicable to _read_ - i.e `get...` operations.
        
    - Update:
         ```
        @...
        public @interface Secure {
            ...
            String securedUpdate() default "";
            String rolesAllowedUpdate() default "";
            String preAuthorizeUpdate() default "";
            String postAuthorizeUpdate() default "";
            String preFilterUpdate() default "";
            String preFilterTargetUpdate() default "";
            String postFilterUpdate() default "";
            ...
        }
        ```
        As their suffixes suggest, these are applicable to `update...` operations.
        
    - Delete:
         ```
        @...
        public @interface Secure {
            ...
            String securedDelete() default "";
            String rolesAllowedDelete() default "";
            String preAuthorizeDelete() default "";
            String postAuthorizeDelete() default "";
            String preFilterDelete() default "";
            String preFilterTargetDelete() default "";
            String postFilterDelete() default "";
            ...
        }
        ```
        As their suffixes suggest, these are applicable to `delete...` operations.
    
    Let's showcase these subcategories with the following example:
    
    ```
    @Entity
    
    @Secure(
        rolesAllowed = "permitAll()", 
        rolesAllowedCreate = "ROLE_ADMIN", 
        rolesAllowedUpdate = "ROLE_SECRETARY",
        rolesAllowedDelete = "ROLE_SUPERVISOR"
        )
    public class Person {
        @Id
        private String id = UUID.randomUUID().toString();
        private String name;
        private Integer age;
        private String address;
    }
    ```
    And the resulting service bean:
    
    ```
    @...
    @RolesAllowed("permitAll()")
    public class PersonGraphQLService {
      
      ...
      
      @GraphQLQuery
      public List<Person> allPersons(int limit, int offset) {
        return ApiLogic.getAll(personDataManager, limit, offset);
      }
    
      @GraphQLQuery
      public Person getPersonById(String input) {
        return ApiLogic.getById(personDataManager,input);
      }
    
      @GraphQLQuery
      public List<Person> getPersonsById(List<String> input) {
        return ApiLogic.getCollectionById(personDataManager, input);
      }
    
      @GraphQLMutation
      @RolesAllowed("ROLE_ADMIN")
      public Person addPerson(Person input) {
        Person entity = ApiLogic.add(personDataManager, input, personMetaOperations);
        return entity;
      }
    
      @GraphQLMutation
      @RolesAllowed("ROLE_SECRETARY")
      public Person updatePerson(Person input) {
        Person entity = ApiLogic.update(personDataManager, input, reflectionCache, personMetaOperations);
        return entity;
      }
    
      @GraphQLMutation
      @RolesAllowed("ROLE_SUPERVISOR")
      public Person deletePerson(Person input) {
        Person entity = ApiLogic.delete(personDataManager, reflectionCache, input, personMetaOperations);
        return entity;
      }
    
      @GraphQLMutation
      @RolesAllowed("ROLE_ADMIN")
      public List<Person> addPersons(List<Person> input) {
        List<Person> entities = ApiLogic.addCollection(personDataManager, input, personMetaOperations);
        return entities;
      }
    
      @GraphQLMutation
      @RolesAllowed("ROLE_SECRETARY")
      public List<Person> updatePersons(List<Person> input) {
        List<Person> entities = ApiLogic.updateCollection(personDataManager, input, personMetaOperations);
        return entities;
      }
    
      @GraphQLMutation
      @RolesAllowed("ROLE_SUPERVISOR")
      public List<Person> deletePersons(List<Person> input) {
        List<Person> entities = ApiLogic.deleteCollection(personDataManager, input, personMetaOperations);
        return entities;
      }
    }
    ```
    The breakdown:
     - On the class level, spring security is set to `"permitAll()"`, which is therefore the default for all contained methods which do not have their own overriding security annotation. In this particular case, this includes all _read_ related resolvers such as `all...`, `get...ById`, and `get...sById`. Recall the `rolesAllowed = "permitAll()"` argument we passed to `@Secure`.
     
     - The _create_, or `add...` methods are annotated with `@RolesAllowed("ROLE_ADMIN")`, such that only users with an admin role can use them. Recall the `rolesAllowedCreate = "ROLE_ADMIN"` we passed to `@Secure`.
     
     - the `update...` methods are annotated with `@RolesAllowed("ROLE_SECRETARY")`. Recall the `rolesAllowedUpdate = "ROLE_SECRETARY"` argument that was passed to `@Secure`.
     
     - The `delete...` methods are annotated with `@RolesAllowed("ROLE_SUPERVISOR")`. Recall the `rolesAllowedDelete = "ROLE_SUPERVISOR"` argument passed to `@Secure`.
     
 
 2. Annotation arguments that were passed to a field level `@Secure`. Specifically, a field level `@Secure(...)` adorning a field also annotated with a `@GetBy`, `@GetAllBy` or `@GetByUnique` annotation. This is useful for defining granular access control for the corresponding API exposed resolvers. For example:
    ```
    @Entity
    public class Person {
        @Id
        private String id = UUID.randomUUID().toString();
        @GetBy @Secure(preAuthorize = "ROLE_ADMIN")
        private String name;
        private Integer age;
        private String address;
    }
    ```
    Results in the following autogenerated code:
    ```
      @GraphQLQuery
      @PreAuthorize("ROLE_ADMIN")
      public List<Person> getPersonsByName(String name) {
        return ApiLogic.getBy(personDataManager, "name", name);
      }
    ```
    The same flow applies to `@GetAllBy` and `@GetByUnique`.
    
#### That's all for now, happy coding!
### License
Apache 2.0